#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass article
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

libjio - A library for journalled I/O 
\layout Author

Alberto Bertogli (albertogli@telpin.com.ar) 
\layout Standard


\begin_inset LatexCommand \tableofcontents{}

\end_inset 


\layout Section

Introduction
\layout Standard


\emph on 
libjio
\emph default 
 is a library for doing journalled transaction-oriented I/O, providing atomicity
 warantees and a simple to use but powerful API.
\layout Standard

This document explains the design of the library, how it works internally
 and why it works that way.
 You should read it even if you don't plan to do use the library in strange
 ways, it provides (or at least tries to =) an insight view on how the library
 performs its job, which can be very valuable knowledge when working with
 it.
\layout Standard

To the user, libjio provides two groups of functions, one UNIX-alike that
 implements the journalled versions of the classic functions (
\emph on 
open()
\emph default 
, 
\emph on 
read()
\emph default 
, 
\emph on 
write()
\emph default 
 and friends); and a lower-level one that center on transactions and allows
 the user to manipulate them directly by providing means of commiting and
 rollbacking.
 The former, as expected, are based on the latter and interact safely with
 them.
 Besides, it's designed in a way that allows efficient and safe interaction
 with I/O performed from outside the library in case you want to.
\layout Standard

The following sections describe different concepts and procedures that the
 library bases its work on.
 It's not intended to be a replace to reading the source code: please do
 so if you have any doubts, it's not big at all (less than 800 lines, including
 comments) and I hope it's readable enough.
 If you think that's not the case, please let me know and I'll try to give
 you a hand.
\layout Section

General on-disk data organization
\layout Standard

On the disk, the file you are working on will look exactly as you expect
 and hasn't got a single bit different that what you would get using the
 regular API.
 But, besides the working file, you will find a directory named after it
 where the journaling information lives.
 
\layout Standard

Inside, there are two kind of files: the lock file and transaction files.
 The first one is used as a general lock and holds the next transaction
 ID to assign, and there is only one; the second one holds one transaction,
 which is composed by a header of fixed size and a variable-size payload,
 and can be as many as in-flight transactions.
 
\layout Standard

This impose some restrictions to the kind of operations you can perform
 over a file while it's currently being used: you can't move it (because
 the journal directory name depends on the filename) and you can't unlink
 it (for similar reasons).
 Some other operations, like truncating, are also done outside the library
 and the user is expected to do them atomically when no transactions are
 currently being done.
 
\layout Standard

This warnings are no different from a normal simultaneous use under classic
 UNIX environments, but they are here to remind you that even tho the library
 warantees a lot and eases many things from its user (specially from complex
 cases, like multiple threads using the file at the same time), you should
 still be careful when doing strange things with files while working on
 them.
 
\layout Subsection

The transaction file
\layout Standard

The transaction file is composed of two main parts: the header and the payload.
\layout Standard

The header holds basic information about the transaction itself, including
 the ID, some flags, the offset to commit to and the lenght of the data.
 The payload holds the data, in three parts: user-defined data, previous
 data, and real data.
\layout Standard

User-defined data is not used by the library itself, but it's a space where
 the user can save private data that can be useful later.
 Previous data is saved by the library prior applying the commit, so transaction
s can be rollbacked.
 Real data is just the data to save to the disk, and it is saved because
 if a crash occurs when while we are applying the transaction we can recover
 gracefuly.
\layout Section

The commit procedure
\layout Standard

We call "commit" to the action of 
\emph on 
safely
\emph default 
 and 
\emph on 
atomically
\emph default 
 write some given data to the disk.
\layout Standard

The former, 
\emph on 
safely
\emph default 
, means that after a commit has been done we can assume the data will not
 get lost and can be retrieved, unless of course some major event happens
 (like a hardware failure).
 For us, this means that the data was effectively written to the disk and
 if a crash occurs after the commit operation has returned, the operation
 will be complete and data will be available from the file.
\layout Standard

The latter, 
\emph on 
atomically
\emph default 
, warantees that the operation is either completely done, or not done at
 all.
 This is a really common word, specially if you have worked with multiprocessing
, and should be quite familiar.
 We implement atomicity by combining fine-grained locks and journalling,
 which can assure us both to be able to recover from crashes, and to have
 exclusive access to a portion of the file without having any other transaction
 overlap it.
\layout Standard

Well, so much for talking, now let's get real; libjio applies commits in
 a very simple and straightforward way, inside 
\emph on 
jtrans_commit()
\emph default 
:
\layout Itemize

Lock the section where the commit takes place
\layout Itemize

Open the transaction file
\layout Itemize

Write the header
\layout Itemize

Write the user data (if any)
\layout Itemize

Read the previous data from the file
\layout Itemize

Write the previous data in the transaction
\layout Itemize

Write the data to commit to the transaction file
\layout Itemize

Write the data to the file
\layout Itemize

Mark the transaction as commited by setting a flag in the header
\layout Itemize

Unlink the transaction file
\layout Itemize

Unlock the section where the commit takes place
\layout Standard

This may look as a lot of steps, but they're not as much as it looks like
 inside the code, and allows a recovery from interruptions in every step
 of the way (or even in the middle of a step).
\layout Section

The rollback procedure
\layout Standard

First of all, rollbacking is like 
\begin_inset Quotes eld
\end_inset 

undo
\begin_inset Quotes erd
\end_inset 

 a commit: return the data to the state it had exactly before a given commit
 was applied.
 Due to the way we handle commits, doing this operation becomes quite simple
 and straightforward.
\layout Standard

In the previous section we said that each transaction held, besides the
 data to commit to the disk, the data that was on it before commiting.
 That data is saved precisely to be able to rollback.
 So, to rollback a transaction all that has to be done is recover that 
\begin_inset Quotes eld
\end_inset 

previous data
\begin_inset Quotes erd
\end_inset 

 from the transaction we want to rollback, and save it to the disk.
 In the end, this ends up being a new transaction with the previous data
 as the new one, so we do that: create a new transaction structure, fill
 in the data from the transaction we want to rollback, and commit it.
 All this is performed by 
\emph on 
jtrans_rollback()
\emph default 
.
\layout Standard

By doing this we can provide the same warranties a commit has, it's really
 fast, eases the recovery, and the code is simple and clean.
 What a deal.
\layout Standard

But be aware that rollbacking is dangerous.
 And I really mean it: you should 
\series bold 
\emph on 
only
\series default 
\emph default 
 do it if you're really sure it's ok.
 Consider, for instance, that you commit transaction A, then B, and then
 you rollback A.
 If A and B happen to touch the same portion of the file, the rollback will,
 of course, not return the state previous to B, but previous to A.
 If it's not done safely, this can lead to major corruption.
 Now, if you add to this transactions that extend the file (and thus rollbacking
 truncates it back), you not only have corruption but data loss.
 So, again, be aware, I can't stress this enough, 
\series bold 
\emph on 
rollback only if you really really know what you are doing
\series default 
\emph default 
.
\layout Section

The recovery procedure
\layout Standard

Recovering from crashes is done by the 
\emph on 
jfsck()
\emph default 
 call (or the program 
\emph on 
jiofsck
\emph default 
 which is just a simple invocation to that function), which opens the file
 and goes through all transactions in the journal (remember that transactions
 are removed from the journal directory after they're applied), loading
 and recommiting them if possible.
 There are several steps where it can fail: there could be no journal, a
 given transaction file might be corrupted, incomplete, and so on; but in
 the end, there are two cases regarding each transaction: either it's complete
 and can be reapplied, or not.
\layout Standard

In the case the transaction is not complete, there is no possibility that
 it has been partially applied to the disk, remember that, from the commit
 procedure, we only apply the transaction 
\emph on 
after
\emph default 
 saving it in the journal, so there is really nothing left to be done.
\layout Standard

If the transaction is complete, we only need to recommit: if the transaction
 was either not applied at all, partially applied or completely applied,
 it makes no difference as we are now capable of completing it, and do so.
\layout Standard

In any case, after making the recovery you can simply remove the journal
 entirely and let the library create a new one, and you can be sure that
 transaction atomicity was preserved.
\layout Section

High-level functions
\layout Standard

We call 
\emph on 
high-level functions
\emph default 
 to the ones provided by the library that emulate the good old unix file
 manipulation calls.
 Most of them are just wrappers around commits, and implement proper locking
 when operating in order to allow simultaneous operations (either across
 threads or processes).
 They are described in detail in the manual pages, we'll only list them
 here for completion:
\layout Itemize

jopen()
\layout Itemize

jread(), jpread(), jreadv()
\layout Itemize

jwrite(), jpwrite(), jwritev()
\layout Itemize

jtruncate()
\layout Itemize

jclose()
\layout Section

ACID (or How does libjio fit into theory)
\layout Standard

I haven't read much theory about this, and the library was implemented basically
 by common sense and not theorethical study.
 
\layout Standard

However, I'm aware that database people like ACID (well, that's not news
 for anybody ;), which they say mean "Atomicity, Consistency, Isolation,
 Durability" (yeah, right!).
 
\layout Standard

So, even libjio is not a purely database thing, it can be used to achieve
 those attributes in a simple and efficient way.
 
\layout Standard

Let's take a look one by one:
\layout Itemize

Atomicity: In a transaction involving two or more discrete pieces of information
, either all of the pieces are committed or none are.
 This has been talked before and we've seen how the library achieves this
 point, mostly based on locks and relying on a commit procedure.
\layout Itemize

Consistency: A transaction either creates a new and valid state of data,
 or, if any failure occurs, returns all data to its state before the transaction
 was started.
 This, like atomicity, has been discussed before, specially in the recovery
 section, when we saw how in case of a crash we end up with a fully applied
 transaction, or no transaction applied at all.
\layout Itemize

Isolation: A transaction in process and not yet committed must remain isolated
 from any other transaction.
 This comes as a side effect of doing proper locking on the sections each
 transaction affect, and guarantees that there can't be two transactions
 working on the same section at the same time.
\layout Itemize

Durability: Committed data is saved by the system such that, even in the
 event of a failure and system restart, the data is available in its correct
 state.
 For this point we rely on the disk as a method of permanent storage, and
 expect that when we do syncronous I/O, data is safely written and can be
 recovered after a crash.
\layout Section

Working from outside
\layout Standard

If you want, and are careful enough, you can safely do I/O without using
 the library.
 Here I'll give you some general guidelines that you need to follow in order
 to prevent corruption.
 Of course you can bend or break them according to your use, this is just
 a general overview on how to interact from outside.
 
\layout Itemize

Lock the sections you want to use: the library, as we have already exposed,
 relies on fcntl locking; so, if you intend to operate on parts on the file
 while using it, you should lock them.
 
\layout Itemize

Don't tuncate, unlink or rename: these operations have serious implications
 when they're done while using the library, because the library itself assumes
 that names don't change, and files don't dissapear beneath it.
 It could potentially lead to corruption, although most of the time you
 would just get errors from every call.
\the_end
